var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// src/client.ts
import axios from "axios";
import axiosRetry from "axios-retry";

// src/types/channel.ts
var Channel = class {
  constructor(raw) {
    this.raw = raw;
  }
  toRaw() {
    return this.raw;
  }
  get channelId() {
    return this.raw.id;
  }
  get name() {
    return this.raw.name;
  }
  get englishName() {
    return this.raw.english_name;
  }
  get channelType() {
    return this.raw.type;
  }
  get organization() {
    return this.raw.org;
  }
  get group() {
    var _a, _b;
    return (_b = this.raw.group) != null ? _b : (_a = this.raw.suborg) == null ? void 0 : _a.substr(2);
  }
  get sortKey() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.raw.suborg) != null ? _a : this.group) != null ? _b : this.organization) != null ? _c : this.name;
  }
  get avatarUrl() {
    return this.raw.photo;
  }
  get bannerUrl() {
    return this.raw.banner;
  }
  get twitterName() {
    return this.raw.twitter;
  }
  get videoCount() {
    return typeof this.raw.video_count === "string" ? Number(this.raw.video_count) : this.raw.video_count;
  }
  get subscriberCount() {
    return typeof this.raw.subscriber_count === "string" ? Number(this.raw.subscriber_count) : this.raw.subscriber_count;
  }
  get viewCount() {
    return typeof this.raw.view_count === "string" ? Number(this.raw.view_count) : this.raw.view_count;
  }
  get clipCount() {
    return typeof this.raw.clip_count === "string" ? Number(this.raw.clip_count) : this.raw.clip_count;
  }
  get language() {
    return this.raw.lang;
  }
  get createdAt() {
    return typeof this.raw.published_at === "string" ? new Date(this.raw.published_at) : void 0;
  }
  get isInactive() {
    return this.raw.inactive;
  }
  get description() {
    return this.raw.description;
  }
};

// src/types/comment.ts
var Comment = class {
  constructor(raw) {
    this.raw = raw;
  }
  get key() {
    return this.raw.comment_key;
  }
  get videoId() {
    return this.raw.video_id;
  }
  get content() {
    return this.raw.message;
  }
};

// src/types/enums/channel-type.ts
var ChannelType;
(function(ChannelType2) {
  ChannelType2["VTuber"] = "vtuber";
  ChannelType2["Subber"] = "subber";
})(ChannelType || (ChannelType = {}));

// src/types/enums/extra-data.ts
var ExtraData;
(function(ExtraData2) {
  ExtraData2["Clips"] = "clips";
  ExtraData2["Refers"] = "refers";
  ExtraData2["Sources"] = "sources";
  ExtraData2["Simulcasts"] = "simulcasts";
  ExtraData2["Mentions"] = "mentions";
  ExtraData2["Description"] = "description";
  ExtraData2["LiveInfo"] = "live_info";
  ExtraData2["ChannelStats"] = "channel_stats";
  ExtraData2["Songs"] = "songs";
})(ExtraData || (ExtraData = {}));

// src/types/enums/sort-order.ts
var SortOrder;
(function(SortOrder2) {
  SortOrder2["Ascending"] = "asc";
  SortOrder2["Descending"] = "desc";
})(SortOrder || (SortOrder = {}));

// src/types/enums/video-search-type.ts
var VideoSearchType;
(function(VideoSearchType2) {
  VideoSearchType2["Clips"] = "clips";
  VideoSearchType2["Videos"] = "videos";
  VideoSearchType2["Collabs"] = "collabs";
})(VideoSearchType || (VideoSearchType = {}));

// src/types/enums/video-status.ts
var VideoStatus;
(function(VideoStatus2) {
  VideoStatus2["New"] = "new";
  VideoStatus2["Upcoming"] = "upcoming";
  VideoStatus2["Live"] = "live";
  VideoStatus2["Past"] = "past";
  VideoStatus2["Missing"] = "missing";
})(VideoStatus || (VideoStatus = {}));

// src/types/enums/video-type.ts
var VideoType;
(function(VideoType2) {
  VideoType2["Stream"] = "stream";
  VideoType2["Clip"] = "clip";
})(VideoType || (VideoType = {}));

// src/types/song.ts
var Song = class {
  constructor(raw) {
    this.raw = raw;
  }
  get artUrl() {
    return this.raw.art;
  }
  get name() {
    return this.raw.name;
  }
  get startTime() {
    return this.raw.start;
  }
  get endTime() {
    return this.raw.end;
  }
  get iTunesId() {
    return this.raw.itunesid;
  }
  get artist() {
    return this.raw.original_artist;
  }
};

// src/types/video.ts
var Video = class {
  constructor(raw) {
    this.raw = raw;
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    this.channel = new Channel(this.raw.channel);
    this.comments = (_b = (_a = this.raw.comments) == null ? void 0 : _a.map((comment) => new Comment(comment))) != null ? _b : [];
    this.clips = (_d = (_c = this.raw.clips) == null ? void 0 : _c.map((video) => new Video(video))) != null ? _d : [];
    this.sources = (_f = (_e = this.raw.sources) == null ? void 0 : _e.map((video) => new Video(video))) != null ? _f : [];
    this.refers = (_h = (_g = this.raw.refers) == null ? void 0 : _g.map((video) => new Video(video))) != null ? _h : [];
    this.simulcasts = (_j = (_i = this.raw.simulcasts) == null ? void 0 : _i.map((video) => new Video(video))) != null ? _j : [];
    this.mentions = (_l = (_k = this.raw.mentions) == null ? void 0 : _k.map((channel) => new Channel(channel))) != null ? _l : [];
    this.songs = (_n = (_m = this.raw.songs) == null ? void 0 : _m.map((song) => new Song(song))) != null ? _n : [];
  }
  toRaw() {
    return this.raw;
  }
  get videoId() {
    return this.raw.id;
  }
  get title() {
    return this.raw.title;
  }
  get videoType() {
    return this.raw.type;
  }
  get topic() {
    return this.raw.topic_id;
  }
  get publishedAt() {
    return typeof this.raw.published_at === "string" ? new Date(this.raw.published_at) : void 0;
  }
  get availableAt() {
    return typeof this.raw.available_at === "string" ? new Date(this.raw.available_at) : void 0;
  }
  get duration() {
    return this.raw.duration;
  }
  get status() {
    return this.raw.status;
  }
  get scheduledStart() {
    return typeof this.raw.start_scheduled === "string" ? new Date(this.raw.start_scheduled) : void 0;
  }
  get actualStart() {
    return typeof this.raw.start_actual === "string" ? new Date(this.raw.start_actual) : void 0;
  }
  get actualEnd() {
    return typeof this.raw.end_actual === "string" ? new Date(this.raw.end_actual) : void 0;
  }
  get liveViewers() {
    return this.raw.live_viewers;
  }
  get description() {
    return this.raw.description;
  }
  get songCount() {
    return this.raw.songcount;
  }
  get channelId() {
    var _a;
    return (_a = this.raw.channel_id) != null ? _a : this.channel.channelId;
  }
};

// src/client.ts
function querystring(obj) {
  return new URLSearchParams(obj).toString();
}
var HolodexApiClient = class {
  constructor(options) {
    var _a;
    (_a = options.url) != null ? _a : options.url = "https://holodex.net/api/v2";
    this.httpClient = axios.create({
      baseURL: options.url,
      headers: {
        "X-APIKEY": options.apiKey
      }
    });
    axiosRetry(this.httpClient, {
      retries: 3,
      retryDelay: axiosRetry.exponentialDelay,
      retryCondition: (error) => axiosRetry.isNetworkOrIdempotentRequestError(error) || error.code === "ECONNABORTED",
      shouldResetTimeout: true
    });
  }
  async getChannels(params = {}) {
    var _a, _b, _c, _d;
    (_a = params.limit) != null ? _a : params.limit = 25;
    (_b = params.offset) != null ? _b : params.offset = 0;
    (_c = params.order) != null ? _c : params.order = SortOrder.Ascending;
    (_d = params.sort) != null ? _d : params.sort = "org";
    if (params.lang && Array.isArray(params.lang)) {
      params.lang = params.lang.join(",");
    }
    const q = querystring(__spreadProps(__spreadValues({}, params), {
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const { data } = await this.httpClient.get(`/channels?${q}`);
    return data.map((channel) => new Channel(channel));
  }
  async getChannel(channelId) {
    const { data } = await this.httpClient.get(`/channels/${channelId}`);
    return new Channel(data);
  }
  async getVideosByChannelId(channelId, searchType = VideoSearchType.Videos, params = {}) {
    var _a, _b, _c;
    (_a = params.lang) != null ? _a : params.lang = "all";
    (_b = params.limit) != null ? _b : params.limit = 25;
    (_c = params.offset) != null ? _c : params.offset = 0;
    const q = querystring(__spreadProps(__spreadValues({}, params), {
      include: Array.isArray(params.include) ? params.include.join(",") : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(",") : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const { data } = await this.httpClient.get(`/channels/${channelId}/${searchType}?${q}`);
    return data.map((video) => new Video(video));
  }
  async getVideo(videoId, includeComments = false, languages) {
    languages != null ? languages : languages = "all";
    const params = {
      lang: Array.isArray(languages) ? languages.join(",") : languages
    };
    if (includeComments) {
      params.c = 1;
    }
    const q = querystring(params);
    const { data } = await this.httpClient.get(`/videos/${videoId}?${q}`);
    return new Video(data);
  }
  async getLiveVideosByChannelId(channelIds) {
    const q = querystring({
      channels: Array.isArray(channelIds) ? channelIds.join(",") : channelIds
    });
    const { data } = await this.httpClient.get(`/users/live?${q}`);
    return data.map((video) => new Video(video));
  }
  async getLiveVideos(params = {}) {
    var _a, _b;
    (_a = params.lang) != null ? _a : params.lang = "all";
    (_b = params.offset) != null ? _b : params.offset = 0;
    const q = querystring(__spreadProps(__spreadValues({}, params), {
      include: Array.isArray(params.include) ? params.include.join(",") : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(",") : params.lang
    }));
    const { data } = await this.httpClient.get(`/live?${q}`);
    return data.map((video) => new Video(video));
  }
  async getVideos(params = {}) {
    var _a, _b, _c, _d, _e;
    (_a = params.lang) != null ? _a : params.lang = "all";
    (_b = params.limit) != null ? _b : params.limit = 25;
    (_c = params.offset) != null ? _c : params.offset = 0;
    (_d = params.order) != null ? _d : params.order = SortOrder.Descending;
    (_e = params.sort) != null ? _e : params.sort = "available_at";
    const q = querystring(__spreadProps(__spreadValues({}, params), {
      include: Array.isArray(params.include) ? params.include.join(",") : params.include,
      lang: Array.isArray(params.lang) ? params.lang.join(",") : params.lang,
      limit: Math.min(Math.max(params.limit, 1), 50)
    }));
    const { data } = await this.httpClient.get(`/videos?${q}`);
    return data.map((video) => new Video(video));
  }
};

export {
  __commonJS,
  __toModule,
  Channel,
  Comment,
  ChannelType,
  ExtraData,
  SortOrder,
  VideoSearchType,
  VideoStatus,
  VideoType,
  Song,
  Video,
  HolodexApiClient
};
