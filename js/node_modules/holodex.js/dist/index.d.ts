declare const enum ChannelType {
    VTuber = "vtuber",
    Subber = "subber"
}

interface ChannelRaw {
    id: string;
    name: string;
    english_name?: string;
    type: ChannelType;
    org?: string;
    suborg?: string;
    group?: string;
    photo?: string;
    banner?: string;
    twitter?: string;
    video_count?: string;
    subscriber_count?: string;
    view_count?: string;
    clip_count?: number;
    lang?: string;
    published_at?: string;
    inactive: boolean;
    description: string;
}

declare class Channel {
    private raw;
    toRaw(): ChannelRaw;
    /**
     * The unique ID of the channel.
     */
    get channelId(): string;
    /**
     * The channel's name.
     */
    get name(): string;
    /**
     * The channel's name in English, if it has one.
     */
    get englishName(): string;
    /**
     * The type of the channel, either vtuber or subber.
     */
    get channelType(): ChannelType;
    /**
     * The channel's organization. Mainly used for VTubers only.
     */
    get organization(): string;
    /**
     * The channel's group/suborganization. Mainly used for VTubers only, that allows them to be sorted internally.
     */
    get group(): string;
    get sortKey(): string;
    /**
     * The internal URL of the channel's profile picture.
     */
    get avatarUrl(): string;
    /**
     * The internal URL of the channel's channel banner.
     */
    get bannerUrl(): string;
    /**
     * The channel's Twitter handle, if they have one.
     */
    get twitterName(): string;
    /**
     * The number of videos the channel has uploaded.
     */
    get videoCount(): number;
    /**
     * The estimated amount of subscribers the channel has.
     */
    get subscriberCount(): number;
    /**
     * The total number of views the channel has.
     */
    get viewCount(): number;
    /**
     * The total number of clips associated with this channel. Mainly used for VTubers only.
     */
    get clipCount(): number;
    /**
     * The language of the channel. Mainly used for Subbers only.
     */
    get language(): string;
    /**
     * The date this channel was created.
     */
    get createdAt(): Date;
    /**
     * Whether or not the channel has been marked as inactive.
     */
    get isInactive(): boolean;
    /**
     * The channel's description on YouTube.
     */
    get description(): string;
    constructor(raw: ChannelRaw);
}

interface CommentRaw {
    comment_key: string;
    video_id: string;
    message: string;
}

declare class Comment {
    private raw;
    /**
     * The unique key associated with the comment.
     */
    get key(): string;
    /**
     * The video ID the comment is linked to.
     */
    get videoId(): string;
    /**
     * The message content of the comment. Usually contains timestamps.
     */
    get content(): string;
    constructor(raw: CommentRaw);
}

/**
 * A enum which contains strings that allow extra data to be returned when requesting videos.
 */
declare const enum ExtraData {
    /**
     * Include clips using the videos.
     */
    Clips = "clips",
    /**
     * Include videos that refer to other videos.
     */
    Refers = "refers",
    /**
     * Include sources for videos created by Subbers.
     */
    Sources = "sources",
    /**
     * Include simulcast videos alongside the videos.
     */
    Simulcasts = "simulcasts",
    /**
     * Include channels that are mentioned.
     */
    Mentions = "mentions",
    /**
     * Include video descriptions.
     */
    Description = "description",
    /**
     * Include live streams.
     */
    LiveInfo = "live_info",
    /**
     * Include channel stats.
     */
    ChannelStats = "channel_stats",
    /**
     * Include any songs used in the videos.
     */
    Songs = "songs"
}

declare const enum SortOrder {
    Ascending = "asc",
    Descending = "desc"
}

/**
 * A enum that provides different search types when retrieving videos.
 */
declare const enum VideoSearchType {
    /**
     * Retrieve clips including a VTuber
     */
    Clips = "clips",
    /**
     * Retrieve videos uploaded by a Channel
     */
    Videos = "videos",
    /**
     * Retrieve videos that mention a Channel
     */
    Collabs = "collabs"
}

declare const enum VideoStatus {
    New = "new",
    Upcoming = "upcoming",
    Live = "live",
    Past = "past",
    Missing = "missing"
}

declare const enum VideoType {
    Stream = "stream",
    Clip = "clip"
}

interface ChannelVideosParam {
    /**
     * Comma separated list of extra info for video
     */
    include?: ExtraData[] | string;
    /**
     * A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
     */
    lang?: string | string[];
    /**
     * Results limit. Has a maximum of 50.
     */
    limit?: number;
    /**
     * Offset results
     */
    offset?: number;
}

interface ChannelsParam {
    /**
     * Comma separated list of languages. Language is a property of Channel, so only Channels satisfying the language will be returned. Leave empty to search for Vtubers and/or all clippers.
     */
    lang?: string | string[];
    /**
     * Results limit. Has a maximum of 50.
     */
    limit?: number;
    /**
     * Offset results
     */
    offset?: number;
    /**
     * ASC or DESC order, default asc.
     */
    order?: SortOrder;
    /**
     * If set, filter for Vtuber belonging to a specific org
     */
    org?: string;
    /**
     * Column to sort on, leave default to use 'org' as sort. Any first level property of channel should work here.
     */
    sort?: keyof ChannelRaw & string;
    /**
     * Type of Channel, whether it's a vtuber or a subber. Leave unset to query all.
     */
    type?: string;
}

interface Options {
    /**
     * Holodex/HoloAPI Server Entrypoint
     * @default "https://holodex.net/api/v2"
     */
    url?: string;
    /**
     * Your personal API key. Be aware that the validity of the key is not checked, so ensure it is correct.
     *
     * You can acquire a API KEY via the Account Settings page.
     */
    apiKey: string;
}

interface SongRaw {
    art: string;
    end: number;
    name: string;
    start: number;
    itunesid: number;
    original_artist: string;
}

interface VideoRaw {
    id: string;
    title: string;
    type: VideoType;
    /**
     * corresponds to a Topic ID, Videos of type `clip` cannot not have topic.
     * Streams may or may not have topic.
     * @example "minecraft"
     */
    topic_id?: string;
    published_at?: string;
    /**
     * Takes on the first non-null value of end_actual, start_actual, start_scheduled, or published_at
     */
    available_at: string;
    /**
     * Duration of the video in seconds
     */
    duration: number;
    status: VideoStatus;
    /**
     * Included when includes contains 'live_info'
     */
    start_scheduled?: string;
    /**
     * Included when includes contains 'live_info'
     */
    start_actual?: string;
    /**
     * Included when includes contains 'live_info'
     */
    end_actual?: string;
    /**
     * Included when includes contains 'live_info'
     */
    live_viewers?: number;
    /**
     * Included when includes contains 'description'
     */
    description?: string;
    /**
     * Number of tagged songs for this video
     */
    songcount?: number;
    channel_id?: string;
    channel: ChannelRaw;
    /**
     * Included when 'includes' contains 'clips'
     */
    clips?: VideoRaw[];
    /**
     * Included when 'includes' contains 'sources'
     */
    sources?: VideoRaw[];
    /**
     * Included when 'includes' contains 'refers'
     */
    refers?: VideoRaw[];
    /**
     * Included when 'includes' contains 'simulcasts'
     */
    simulcasts?: VideoRaw[];
    /**
     * VTubers mentioned by this video, Included when 'includes' contains 'mentions'
     */
    mentions?: ChannelRaw[];
    comments?: CommentRaw[];
    songs?: SongRaw[];
}

interface VideosParam {
    /**
     * Filter by video uploader channel id
     */
    channel_id?: string;
    /**
     * A single Youtube Video ID. If Specified, only this video can be returned (may be filtered out by other conditions though)
     */
    id?: string;
    /**
     * Comma separated list of extra info for video
     */
    include?: ExtraData[] | string;
    /**
     * A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
     */
    lang?: string | string[];
    /**
     * Results limit. Has a maximum of 50.
     */
    limit?: number;
    /**
     * Number of maximum hours upcoming to get upcoming videos by (for rejecting waiting rooms that are two years out)
     */
    max_upcoming_hours?: number;
    /**
     * Filter by mentioned channel id, excludes itself. Generally used to find collabs/clips that include the requested channel
     */
    mentioned_channel_id?: string;
    /**
     * Offset results
     */
    offset?: number;
    /**
     * ASC or DESC order, default asc.
     */
    order?: SortOrder;
    /**
     * If set, filter for Vtuber belonging to a specific org
     */
    org?: string;
    /**
     * Sort by any returned video field
     */
    sort?: keyof VideoRaw & string;
    /**
     * Filter by video status
     */
    status?: VideoStatus;
    /**
     * Filter by video topic id
     */
    topic?: string;
    /**
     * Filter by type of video
     */
    type?: VideoType;
}

declare class Song {
    private raw;
    /**
     * The URL of the cover art.
     */
    get artUrl(): string;
    /**
     * The name of the song.
     */
    get name(): string;
    /**
     * The time in the associated {@link Video} where the song began.
     */
    get startTime(): number;
    /**
     * The time in the associated {@link Video} where the song ended.
     */
    get endTime(): number;
    /**
     * The unique ID of the song on iTunes, if it is on iTunes.
     */
    get iTunesId(): number;
    /**
     * The original artist who created/sang the song.
     */
    get artist(): string;
    constructor(raw: SongRaw);
}

declare class Video {
    private raw;
    toRaw(): VideoRaw;
    /**
     * The unique ID of the video.
     */
    get videoId(): string;
    /**
     * The video's title.
     */
    get title(): string;
    /**
     * The type of video, whether it is a stream or a clip.
     */
    get videoType(): VideoType;
    /**
     * The internal topic ID of the video. Some videos, mostly clips, may not have a topic.
     */
    get topic(): string;
    /**
     * The date the video was published at.
     */
    get publishedAt(): Date;
    /**
     * The date the video was made available. This takes on the first non-null value of {@link Video.publishedAt},
     * {@link Video.actualStart}, {@link Video.scheduledStart}, or {@link Video.actualEnd}.
     */
    get availableAt(): Date;
    /**
     * The duration of the video.
     */
    get duration(): number;
    /**
     * The current status of the video on YouTube.
     */
    get status(): VideoStatus;
    /**
     * The date when the stream started. Used with {@link ExtraData.LiveInfo}
     */
    get scheduledStart(): Date;
    /**
     * The date when the stream actually started. Used with {@link ExtraData.LiveInfo}
     */
    get actualStart(): Date;
    /**
     * The date when the stream ended. Used with {@link ExtraData.LiveInfo}
     */
    get actualEnd(): Date;
    /**
     * The number of people currently watching the stream. Used with {@link ExtraData.LiveInfo}
     */
    get liveViewers(): number;
    /**
     * The description of the video. Used with {@link ExtraData.Description}
     */
    get description(): string;
    /**
     * The number of tagged songs related to this video.
     */
    get songCount(): number;
    /**
     * The channel ID the video creator.
     */
    get channelId(): string;
    /**
     * The {@link Channel} object of the video creator.
     */
    readonly channel: Channel;
    /**
     * A list of comments on this video, usually with timestamps. Used when searching for a specific video.
     */
    readonly comments: Readonly<Comment[]>;
    /**
     * A list of clips related to this video. Used with {@link ExtraData.Clips}
     */
    readonly clips: Readonly<Video[]>;
    /**
     * A list of sources for videos uploaded by Subbers. Used with {@link ExtraData.Sources}. Has no effect on VTubers.
     */
    readonly sources: Readonly<Video[]>;
    /**
     * A list of videos that are referred by this video. Used with {@link ExtraData.Refers}
     */
    readonly refers: Readonly<Video[]>;
    /**
     * A list of videos that are simulcast on another channel. Used with {@link ExtraData.Simulcasts}
     */
    readonly simulcasts: Readonly<Video[]>;
    /**
     * A list of channels that are mentioned by this video. Used with {@link ExtraData.Mentions}
     */
    readonly mentions: Readonly<Channel[]>;
    /**
     * A list of songs used in this video. Used with {@link ExtraData.Songs}
     */
    readonly songs: Readonly<Song[]>;
    constructor(raw: VideoRaw);
}

declare class HolodexApiClient {
    private httpClient;
    constructor(options: Options);
    /**
     * Retrieves a list of channels that match the given parameters.
     * @param params See {@link ChannelsParam}
     */
    getChannels(params?: ChannelsParam): Promise<Channel[]>;
    /**
     * Retrieves a single channel.
     * @param channelId ID of the Youtube Channel that is being queried
     */
    getChannel(channelId: string): Promise<Channel>;
    /**
     * A simplified endpoint for access channel specific data.
     * @param channelId ID of the Youtube Channel that is being queried
     * @param searchType The type of video resource to fetch. `clips` finds clip videos of a vtuber channel, `videos` finds the channelId channel's uploads, and `collabs` finds videos uploaded by other channels that mention this channelId
     * @param params See {@link ChannelVideosParam}
     */
    getVideosByChannelId(channelId: string, searchType?: VideoSearchType, params?: ChannelVideosParam): Promise<Video[]>;
    /**
     * Retrieves a video object.
     * @param videoId ID of a Youtube Video
     * @param includeComments if true then will reply with timestamp comments for this video
     * @param languages A comma separated list of language codes to filter channels/clips, official streams do not follow this parameter
     */
    getVideo(videoId: string, includeComments?: boolean, languages?: string[] | string): Promise<Video>;
    /**
     * This endpoint is similar to the /live endpoint and usually replies much faster. It is more friendly in general. The cost to execute a lookup is significantly cheaper. It's unfortunately less customizable as a result.
     *
     * We recommends using this if you have a fixed set of channel IDs to look up status for.
     *
     * @param channelIds comma separated Youtube Channel IDs
     */
    getLiveVideosByChannelId(channelIds: string | string[]): Promise<Video[]>;
    /**
     * Retrieve all live streams for the given paramaters.
     *
     * This is somewhat similar to calling `getVideos`, but this endpoint imposes default values on the query parameters.
     *
     * @param params See {@link VideosParam}
     */
    getLiveVideos(params?: VideosParam): Promise<Video[]>;
    /**
     * Retrieve videos matching the given parameters.
     *
     * @param params See {@link VideosParam}
     */
    getVideos(params?: VideosParam): Promise<Video[]>;
}

export { Channel, ChannelRaw, ChannelType, ChannelVideosParam, ChannelsParam, Comment, CommentRaw, ExtraData, HolodexApiClient, Options, Song, SongRaw, SortOrder, Video, VideoRaw, VideoSearchType, VideoStatus, VideoType, VideosParam };
